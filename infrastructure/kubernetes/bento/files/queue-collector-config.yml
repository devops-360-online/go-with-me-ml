input:
  amqp_1:
    urls:
      - "${RABBITMQ_URL}"
    source_address: "inference_results"
    credit: 64

pipeline:
  processors:
    # Log the received result message
    - log:
        level: INFO
        message: "Received result message: ${! json() }"
    
    # Parse token usage from the output field
    - mapping: |
        # Extract token usage from output JSON
        let output_object = this.output.parse_json()
        let total_tokens = output_object.token_usage.total_tokens.number()
        let prompt_tokens = output_object.token_usage.prompt_tokens.number()
        let completion_tokens = output_object.token_usage.completion_tokens.number()
        
        # Store in metadata for later use
        meta token_usage = {
          "total": total_tokens,
          "prompt": prompt_tokens,
          "completion": completion_tokens
        }
        
        # Pass through original message
        root = this
    
    # Adjust token quotas in Redis based on actual token usage
    - try:
        - redis:
            url: "${REDIS_URL}"
            command: HINCRBY
            args_mapping: |
              root = [
                "user:" + this.user_id + ":quota:daily:tokens",
                "used",
                meta("token_usage").total
              ]
      catch:
        - log:
            level: ERROR
            message: "Failed to adjust daily token quota in Redis: ${! error() }"
    
    # Also update monthly token quota
    - try:
        - redis:
            url: "${REDIS_URL}"
            command: HINCRBY
            args_mapping: |
              root = [
                "user:" + this.user_id + ":quota:monthly:tokens",
                "used",
                meta("token_usage").total
              ]
      catch:
        - log:
            level: ERROR
            message: "Failed to adjust monthly token quota in Redis: ${! error() }"
    
    # Store results in PostgreSQL
    - try:
        - sql_raw:
            driver: postgres
            dsn: "${POSTGRES_DSN}"
            query: |
              UPDATE requests
              SET result = $1,
                  status = 'completed',
                  completed_at = NOW(),
                  prompt_tokens = $2,
                  completion_tokens = $3,
                  total_tokens = $4
              WHERE request_id = $5
            args_mapping: |
              root = [
                this.output,
                meta("token_usage").prompt,
                meta("token_usage").completion,
                meta("token_usage").total,
                this.request_id
              ]
      catch:
        - log:
            level: ERROR
            message: "Failed to store result in PostgreSQL: ${! error() }"
    
    # Final transformation for response
    - mapping: |
        root = {
          "request_id": this.request_id.string(),
          "user_id": this.user_id.string(),
          "status": "completed",
          "tokens_used": meta("token_usage").total.string(),
          "message": "Result collected and processed successfully"
        }

    # Log the final processed message
    - log:
        level: INFO
        message: "Result processing completed: ${! json() }"

output:
  drop: {} 